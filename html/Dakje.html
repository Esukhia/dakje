<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>Dakje API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Dakje</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># django setup
import os
import logging
import time
import multiprocessing

import django
os.environ.setdefault(&#34;DJANGO_SETTINGS_MODULE&#34;, &#34;web.settings&#34;)
django.setup()


# editor
import sys

from functools import partial, wraps
from collections import Counter
from PyQt5 import QtCore, QtWidgets, QtGui
from django.db import transaction

from widgets import (MenuBar, ToolBar, StatusBar, CentralWidget,
                     EditTokenDialog, Highlighter)
                    #  EditTokenDialog, Highlighter, DictionaryEditorWidget)

from managers import ActionManager, TokenManager, ViewManager, FormatManager, Token 
from storage.models import Token
Token.objects.all().delete()

from web.settings import BASE_DIR, FILES_DIR

# Logger
logging.basicConfig(level=logging.DEBUG,
                    format=&#39;%(asctime)s %(levelname)-8s %(message)s&#39;,
                    datefmt=&#39;%Y-%m-%d %H:%M:%S&#39;)
logger = logging.getLogger(__name__)


# Timed decorator #
def timed(func):
    &#34;&#34;&#34;This decorator prints the execution time for the decorated function.&#34;&#34;&#34;
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        logger.debug(&#34;{} ran in {}s&#34;.format(
            func.__name__, round(end - start, 5)))
        return result
    return wrapper

# Exception
class ExceptionHandler(QtCore.QObject):

    errorSignal = QtCore.pyqtSignal()

    def __init__(self):
        super(ExceptionHandler, self).__init__()

    def handler(self, exctype, value, traceback):
        self.errorSignal.emit()
        sys._excepthook(exctype, value, traceback)


exceptionHandler = ExceptionHandler()
sys._excepthook = sys.excepthook
sys.excepthook = exceptionHandler.handler


class CommandEditText(QtWidgets.QUndoCommand):

    def __init__(self, editor, text, description):
        super(CommandEditText, self).__init__(description)
        self.editor = editor
        self.oldText = self.editor.toPlainText()
        self.newText = text

    def redo(self):
        self.editor.setText(self.newText)
        print(f&#39;newText : {self.newText}&#39;)

    def undo(self):
        self.editor.setText(self.oldText)
        print(f&#39;oldText - {self.oldText}&#39;)


class Editor(QtWidgets.QMainWindow):
    BASE_DIR = os.path.dirname(__name__)
    SEGMENT_WORDS = [&#39;་&#39;, &#39;།&#39;, &#39;\n&#39;]

    @timed
    def __init__(self, parent=None):
        super().__init__(parent)
        self.initProperties()
        self.initManagers()
        self.initUI()
        self.bindEvents()
        self.setWindowTitle(&#34;དག་བྱེད།&#34;)
        self.setWindowIcon(QtGui.QIcon(
            os.path.join(BASE_DIR, &#34;icons&#34;, &#34;dakje.ico&#34;)))
        self.setWindowState(QtCore.Qt.WindowMaximized)
        # self.wordcount = 0

        self.textEdit.setUndoRedoEnabled(False)

        self.textEdit.setPlainText = self.ignoreTextChanged(
            self.ignoreCursorPositionChanged(self.textEdit.setPlainText))
        self.textEdit.setSelection = self.ignoreTextChanged(
            self.ignoreCursorPositionChanged(self.textEdit.setSelection))


    def ignoreEvent(self, func, signal, event):
        def _func(*arg, **kwargs):
            signal.disconnect()
            func(*arg, **kwargs)
            signal.connect(event)
        return _func

    def ignoreCursorPositionChanged(self, func):
        return self.ignoreEvent(func,
                                self.textEdit.cursorPositionChanged,
                                self.cursorPositionChanged)

    def ignoreTextChanged(self, func):
        return self.ignoreEvent(func,
                                self.textEdit.textChanged,
                                self.textChanged)

    def initProperties(self):
        self.tokens = []
        self.formats = []
        self.mode = &#39;Level Mode&#39;  # LEVEL_MODE, EDITOR_MODE
        self.view = None  # PLAIN_TEXT_VIEW, SPACE_VIEW...
        self.filename = None

        self.editTokenDialog = EditTokenDialog(self)
        # self.dictionaryDialog = DictionaryEditorWidget(self)

    def initManagers(self):
        self.undoStk = QtWidgets.QUndoStack(self)
        self.actionManager = ActionManager(self)
        self.tokenManager = TokenManager(self)
        self.tokenList = Token(self)
        self.viewManager = ViewManager(self)
        self.formatManager = FormatManager(self)

    def initUI(self):
        self.actionManager.createActions()

        self.menuBar = MenuBar(self.actionManager, parent=self)
        self.setMenuBar(self.menuBar)

        # TODO group doesn&#39;t really work for mutually exclusive, has to be done manually
        # self.viewActionGroup =  QtWidgets.QActionGroup(self)
        # self.viewActionGroup.addAction(self.actionManager.spaceViewAction)
        # self.viewActionGroup.addAction(self.actionManager.tagViewAction)


        self.toolBar = ToolBar(self.actionManager, parent=self)
        self.addToolBar(self.toolBar)

        self.statusBar = StatusBar(parent=self)
        self.setStatusBar(self.statusBar)

        self.centralWidget = CentralWidget(self)
        self.setCentralWidget(self.centralWidget)

        self.highlighter = Highlighter(self.textEdit.document(), self)

        self.setStyleSheet(&#39;QMainWindow{background-color: white}&#39;)
        self.textEdit.setStyleSheet(
            &#39;border: none; margin: 10px&#39;)

        # default font and font size
        font = QtGui.QFont()
        font.setFamily(&#34;Microsoft Himalaya&#34;)
        font.setPointSize(14)
        self.textEdit.setFont(font)

        # font family
        self.toolBar.addSeparator()
        self.fontPicker = QtWidgets.QFontComboBox()
        self.toolBar.addWidget(self.fontPicker)
        self.fontPicker.setCurrentFont(self.textEdit.currentFont())

        # font size
        FONT_SIZES = [6, 8, 9, 10, 11, 12, 13, 14, 18, 24, 36, 48, 64, 72, 96, 144, 288]
        self.fontResizer = QtWidgets.QComboBox()
        self.toolBar.addWidget(self.fontResizer)
        self.fontResizer.addItems([str(s) for s in FONT_SIZES])
        self.fontResizer.setCurrentText(str(font.pointSize()))

        # update when font or size is changed
        self.fontPicker.currentFontChanged.connect(self.changeFont)
        self.fontResizer.currentIndexChanged.connect(self.changeFont)

    def changeFont(self):
        font = self.fontPicker.currentFont()
        font.setPointSize(int(self.fontResizer.currentText()))
        self.textEdit.setFont(font)

    def bindEvents(self):
        self.bindCursorPositionChanged()
        self.bindTextChanged()
        self.bindLevelButtons()

    def bindCursorPositionChanged(self):
        self.textEdit.cursorPositionChanged.connect(self.cursorPositionChanged)

    def bindTextChanged(self):
        self.textEdit.textChanged.connect(self.textChanged)

    def bindLevelButtons(self):
        self.levelTab.level1Button.clicked.connect(
            partial(self.importLevelList, level=1, levelNum=self.levelTab.level1Button))

        self.levelTab.level2Button.clicked.connect(
            partial(self.importLevelList, level=2, levelNum=self.levelTab.level2Button))

        self.levelTab.level3Button.clicked.connect(
            partial(self.importLevelList, level=3, levelNum=self.levelTab.level3Button))

    def closeEvent(self, *args, **kwargs):

        import pickle
        with self.bt.pickled_file.open(&#39;wb&#39;) as f:
            pickle.dump(self.bt.head, f, pickle.HIGHEST_PROTOCOL)

        super().closeEvent(*args, **kwargs)

    def toggleSpaceView(self):
        if self.viewManager.isPlainTextView():
            self.segment()
        
        self.viewManager.toggleSpaceView()
        self.refreshView()

    def toggleTagView(self):
        if self.viewManager.isPlainTextView():
            self.segment()
        self.viewManager.toggleTagView()
        self.refreshView()

    def segment(self, byBlock=False, breakLine=False):
        &#34;&#34;&#34;
        1. Gets the text in textedit, 2. segments it with pybo,
        3. assigns a lists of Token objects to self.tokens,
        4. displays text with refreshview().
        Segmentation by blocks avoids resegmenting the whole document at each change 
            :param self: Editor
            :param byBlock=False: 
            :param breakLine=False: 
        &#34;&#34;&#34;
        if byBlock:
            block = self.textEdit.textCursor().block()
            string = block.text()

            if breakLine:
                block = block.previous()
                string = block.text() + &#39;\n&#39;

            tokens = self.tokenManager.segment(string)
            startIndex, endIndex = self.tokenManager.findByBlockIndex(
                block.blockNumber())

            if startIndex is None:
                self.tokens.extend(tokens)

            else:
                self.tokens[startIndex: endIndex + 1] = tokens
        else:
            string = self.centralWidget.textEdit.toPlainText()
            self.tokens = self.tokenManager.segment(string)

        self.refreshView()

    def resegment(self):
        # FIXME is this really useful?
        string = &#39;&#39;.join([token.text for token in self.tokens])
        tokens = self.tokenManager.segment(string)
        self.tokens = tokens
        self.refreshView()

    @property
    def bt(self):
        return self.tokenManager.tokenizer.tok.trie

    # TextEdit #
    @property
    def textEdit(self):
        return self.centralWidget.textEdit

    @property
    def findWidget(self):
        return self.centralWidget.leftTabWidget.findTab

    @property
    def levelTab(self):
        return self.centralWidget.tabWidget.levelTab

    @property
    def editorTab(self):
        return self.centralWidget.tabWidget.editorTab

    def isLevelMode(self):
        return (self.centralWidget.tabWidget.currentIndex() == 0)

    def isEditorMode(self):
        return (self.centralWidget.tabWidget.currentIndex() == 1)

    # TextEdit Actions #
    def newFile(self):
        self.textEdit.newFile()

    def openFile(self):
        self.textEdit.openFile()
        self.segment()

    def saveFile(self):
        self.filename = self.textEdit.saveFile()

    def undo(self):
        # self.textEdit.undo()
        self.QUndoStack.undo()
        print(&#39;undo&#39;)

    def redo(self):
        # self.textEdit.redo()
        self.QUndoStack.redo()
        print(&#39;redo&#39;)

    # TextEdit Events #
    def cursorPositionChanged(self):
        cursor = self.textEdit.textCursor()
        position = cursor.position()

        if (self.viewManager.isTagView() and
                not self.editTokenDialog.isVisible()):
            token = self.tokenManager.find(position)[1]

            if token.pos == &#34;OOV&#34;:
                # TODO
                self.actionManager.dictionaryAction.trigger()
                self.dictionaryDialog.addWord(text=token.text)
            else:
                self.editTokenDialog.setMode(EditTokenDialog.MODE_UPDATE)
                self.editTokenDialog.setToken(token)
                self.editTokenDialog.show()

        self.showStatus(ln=cursor.blockNumber() + 1,
                        col=cursor.columnNumber() + 1)

    def textChanged(self):
        if self.viewManager.isPlainTextView():
            string = self.textEdit.toPlainText()

            if any([string.endswith(w) for w in self.SEGMENT_WORDS]):
                self.segment()
                # self.segment(byBlock=True)

            elif string.endswith(&#39;\n&#39;):
                self.segment()
                # TODO: block mode: bug - if we delete text and try to rewrite new
                # text it copies the already saved text.
                # self.segment(byBlock=True, breakLine=True)

            elif string == &#39;&#39;: 
                self.segment()

    # Import Level List#
    # TODO: set list names when starting the app
    def importLevelList(self, level, levelNum):
        filePath, _ = QtWidgets.QFileDialog.getOpenFileName(self, &#34;Select a level list&#34;, os.path.join(FILES_DIR, &#39;levels&#39;), filter=&#34;UTF-8 ཡིག་རྐྱང་། (*.txt)&#34;)
        splitFilePath = filePath.split(&#39;/&#39;)

        if &#39;&#39; in splitFilePath[:1]:
            return
        else:
            self.fileName = splitFilePath[len(splitFilePath) - 1]
            levelNum.setText(self.fileName)

        with open(filePath, encoding=&#39;utf-8&#39;) as f:
            words = [word[:-1] if word.endswith(&#39;་&#39;) else word
                     for word in [line.rstrip(&#39;\r\n&#39;)
                                  for line in f.readlines()]]

        with transaction.atomic():
            for word in words:
                token = Token.objects.get_or_create(
                    text=word, type=Token.TYPE_UPDATE)[0]
                token.level = level
                token.save()

        self.refreshView()

    def importRuleList(self, level):
        filePath, _ = QtWidgets.QFileDialog.getOpenFileName(self, &#34;Select a rule list&#34;, os.path.join(FILES_DIR, &#39;levels&#39;), filter=&#34;UTF-8 ཡིག་རྐྱང་། (*.txt)&#34;)

        with open(filePath, encoding=&#39;utf-8&#39;) as f:
            rules = [line.rstrip(&#39;\r\n&#39;) for line in f.readlines()]

        self.matcher.match(self.tokens, rules)

        self.refreshView()

    # Refresh #
    def refreshView(self):
        &#34;&#34;&#34;
        docstring here
            :param self: 
        &#34;&#34;&#34;
        # Adds token info from the db
        # - level
        # - sense
        self.tokenManager.applyDict()

        # 
        self.tokenManager.matchRules()

        # keep cursor
        textCursor = self.textEdit.textCursor()
        current = self.tokenManager.find(textCursor.position())

        if current is not None:
            currentToken = current[1]
            distance = textCursor.position() - currentToken.start

        text = self.tokenManager.getString()

        # # Sets text in textEdit before moving on to highlighting
        # self.textEdit.setPlainText(text)

        command = CommandEditText(self.textEdit, text, &#34;Edit text&#34;)
        self.undoStk.push(command)

        if current is not None:
            textCursor.setPosition(currentToken.start + distance)
        else:
            textCursor.setPosition(len(self.textEdit.toPlainText()))

        self.ignoreCursorPositionChanged(
            self.textEdit.setTextCursor)(textCursor)
        self.refreshCoverage()

        # print([t.text for t in self.tokens])
        self.statusBar.showMessage(
            &#39;  &#39; + &#39; &#39;.join([t.text for t in self.tokens[-19:]]))

    def statistics(self):

        # to do: bug fix -
        # if we press enter twice sentence count reinitializes
        # you need to press on enter for it to recognize that the text editor is empty
        # it considers བོད and བོད་ different - the difference is the tseg (not sure if that is a bug)
        # It always counts the first enter

        # Statistics - analyze the text in the text editor

        wordCount = 0  # number of words written
        sentenceCount = 0  # number of sentence written - each new line is considered one sentnece
        typeCount = 0  # number of words used
        max = 0  # maximum number of words in a sentence - longest sentence
        counts = dict()
        sentenceWordCount = []  # records the number of words in each sentence
        wordSentence = 0  # words in a sentence
        verbsPerSen = 0  # verbs in a sentence
        verbSentence = []  # records the number of verbs in each sentence

        # parse through the list and not count the newline
        # for now every newline is considered a completion of one sentence
        for token in self.tokens:

            if token.text == &#34;།&#34;:
                continue
            if token.text != &#34;\n&#34;:
                wordCount += 1
                wordSentence += 1
                if token.pos == &#34;VERB&#34;:
                    verbsPerSen += 1
                if token.text in counts:
                    continue
                else:
                    counts[token.text] = 1
                    typeCount += 1
            else:
                if wordCount == 0:
                    continue
                verbSentence.append(verbsPerSen)
                sentenceCount += 1
                sentenceWordCount.append(wordSentence)
                if max &lt; sentenceWordCount[sentenceCount - 1]:
                    max = sentenceWordCount[sentenceCount - 1]
                wordSentence = 0
                verbsPerSen = 0

        # print(&#34;maximum words in a sentence: &#34;, max)
        # print(&#34;word count: &#34;, wordCount)
        # print(&#34;type count: &#34;, typeCount)
        # print(&#34;sentence count: &#34;, sentenceCount)

        # frequency - the number of times a token is repeated
        frequency = Counter([
            (token.text, token.type, token.pos, token.text_unaffixed) for token in self.tokens])
        print(&#34;Frequency: &#34;, frequency)

        # Updating the Statistics
        self.levelTab.wordCountLabel.setText(str(wordCount))
        self.levelTab.typeCountLabel.setText(str(typeCount))
        self.levelTab.senCountLabel.setText(str(sentenceCount))
        self.levelTab.maxWordLabel.setText(str(max))

    def refreshCoverage(self):

        tokenNum = sum(1 for t in self.tokens if t.type == &#39;TEXT&#39;)
        print(&#39;tokenNum: &#39;, tokenNum)

        self.statistics()

        levelCounter = Counter([
            token.level for token in self.tokens if token.type == &#39;TEXT&#39;])


        def getLevelPercentage(key):
            if tokenNum == 0:
                return 0
            else:
                return levelCounter[key] / tokenNum * 100.0

        # updating the progress bar
        self.levelTab.tokenCoverageProgBar.setValue(100 - getLevelPercentage(None))
        self.levelTab.levelNoneProgBar.setValue(getLevelPercentage(None))
        self.levelTab.level1ProgBar.setValue(getLevelPercentage(1))
        self.levelTab.level2ProgBar.setValue(getLevelPercentage(2))
        self.levelTab.level3ProgBar.setValue(getLevelPercentage(3))

        posCounter = Counter([
            token.pos for token in self.tokens])

        posFreq = posCounter.most_common()
        print(posFreq)
        &#34;&#34;&#34;
        if len(posFreq) &gt;= 1:
            self.editorTab.firstFreqLabel.setText(posFreq[0][0])
            self.editorTab.firstFreqProgBar.setValue(
                posFreq[0][1] / tokenNum * 100.0)

        if len(posFreq) &gt;= 2:
            self.editorTab.secondFreqLabel.setText(posFreq[1][0])
            self.editorTab.secondFreqProgBar.setValue(
                posFreq[1][1] / tokenNum * 100.0)

        if len(posFreq) &gt;= 3:
            self.editorTab.thirdFreqLabel.setText(posFreq[2][0])
            self.editorTab.thirdFreqProgBar.setValue(
                posFreq[2][1] / tokenNum * 100.0)
        &#34;&#34;&#34;

    def getHighlightedLevels(self):
        result = []
        if self.levelTab.levelNoneCheckbox.isChecked():
            result.append(None)
        if self.levelTab.level1Checkbox.isChecked():
            result.append(1)
        if self.levelTab.level2Checkbox.isChecked():
            result.append(2)
        if self.levelTab.level3Checkbox.isChecked():
            result.append(3)
        return result

    def getHighlightedPoses(self):
        result = []
        if self.editorTab.firstFreqCheckbox.isChecked():
            result.append(self.editorTab.firstFreqLabel.text())
        if self.editorTab.secondFreqCheckbox.isChecked():
            result.append(self.editorTab.secondFreqLabel.text())
        if self.editorTab.thirdFreqCheckbox.isChecked():
            result.append(self.editorTab.thirdFreqLabel.text())
        return result

    def getPosRank(self, pos):
        if self.editorTab.firstFreqLabel.text() == pos:
            return 1
        elif self.editorTab.secondFreqLabel.text() == pos:
            return 2
        elif self.editorTab.thirdFreqLabel.text() == pos:
            return 3
        else:
            return None

    def showStatus(self, ln=None, col=None):
        self.statusBar.modeLabel.setText(self.mode)
        self.statusBar.viewLabel.setText(self.viewManager.getStatusDisplay())

        if ln and col:
            self.statusBar.lineLabel.setText(
                &#39;Ln {}, Col {}&#39;.format(ln, col))

def runserver():
    import django
    os.environ.setdefault(&#34;DJANGO_SETTINGS_MODULE&#34;, &#34;web.settings&#34;)
    django.setup()

    from django.core.management import call_command
    call_command(&#39;runserver&#39;, &#39;--noreload&#39;)


def main():
    multiprocessing.Process(target=runserver, daemon=True).start()

    app = QtWidgets.QApplication(sys.argv)
    window = Editor()
    window.show()

    try:
        sys.exit(app.exec_())
    except:
        print(&#34;exiting&#34;)
        sys.exit(1)


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Dakje.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    multiprocessing.Process(target=runserver, daemon=True).start()

    app = QtWidgets.QApplication(sys.argv)
    window = Editor()
    window.show()

    try:
        sys.exit(app.exec_())
    except:
        print(&#34;exiting&#34;)
        sys.exit(1)</code></pre>
</details>
</dd>
<dt id="Dakje.runserver"><code class="name flex">
<span>def <span class="ident">runserver</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runserver():
    import django
    os.environ.setdefault(&#34;DJANGO_SETTINGS_MODULE&#34;, &#34;web.settings&#34;)
    django.setup()

    from django.core.management import call_command
    call_command(&#39;runserver&#39;, &#39;--noreload&#39;)</code></pre>
</details>
</dd>
<dt id="Dakje.timed"><code class="name flex">
<span>def <span class="ident">timed</span></span>(<span>func)</span>
</code></dt>
<dd>
<section class="desc"><p>This decorator prints the execution time for the decorated function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timed(func):
    &#34;&#34;&#34;This decorator prints the execution time for the decorated function.&#34;&#34;&#34;
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        logger.debug(&#34;{} ran in {}s&#34;.format(
            func.__name__, round(end - start, 5)))
        return result
    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Dakje.CommandEditText"><code class="flex name class">
<span>class <span class="ident">CommandEditText</span></span>
<span>(</span><span>editor, text, description)</span>
</code></dt>
<dd>
<section class="desc"><p>QUndoCommand(parent: QUndoCommand = None)
QUndoCommand(str, parent: QUndoCommand = None)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandEditText(QtWidgets.QUndoCommand):

    def __init__(self, editor, text, description):
        super(CommandEditText, self).__init__(description)
        self.editor = editor
        self.oldText = self.editor.toPlainText()
        self.newText = text

    def redo(self):
        self.editor.setText(self.newText)
        print(f&#39;newText : {self.newText}&#39;)

    def undo(self):
        self.editor.setText(self.oldText)
        print(f&#39;oldText - {self.oldText}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QUndoCommand</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Dakje.CommandEditText.redo"><code class="name flex">
<span>def <span class="ident">redo</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>redo(self)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redo(self):
    self.editor.setText(self.newText)
    print(f&#39;newText : {self.newText}&#39;)</code></pre>
</details>
</dd>
<dt id="Dakje.CommandEditText.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>undo(self)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undo(self):
    self.editor.setText(self.oldText)
    print(f&#39;oldText - {self.oldText}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Dakje.Editor"><code class="flex name class">
<span>class <span class="ident">Editor</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<section class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Editor(QtWidgets.QMainWindow):
    BASE_DIR = os.path.dirname(__name__)
    SEGMENT_WORDS = [&#39;་&#39;, &#39;།&#39;, &#39;\n&#39;]

    @timed
    def __init__(self, parent=None):
        super().__init__(parent)
        self.initProperties()
        self.initManagers()
        self.initUI()
        self.bindEvents()
        self.setWindowTitle(&#34;དག་བྱེད།&#34;)
        self.setWindowIcon(QtGui.QIcon(
            os.path.join(BASE_DIR, &#34;icons&#34;, &#34;dakje.ico&#34;)))
        self.setWindowState(QtCore.Qt.WindowMaximized)
        # self.wordcount = 0

        self.textEdit.setUndoRedoEnabled(False)

        self.textEdit.setPlainText = self.ignoreTextChanged(
            self.ignoreCursorPositionChanged(self.textEdit.setPlainText))
        self.textEdit.setSelection = self.ignoreTextChanged(
            self.ignoreCursorPositionChanged(self.textEdit.setSelection))


    def ignoreEvent(self, func, signal, event):
        def _func(*arg, **kwargs):
            signal.disconnect()
            func(*arg, **kwargs)
            signal.connect(event)
        return _func

    def ignoreCursorPositionChanged(self, func):
        return self.ignoreEvent(func,
                                self.textEdit.cursorPositionChanged,
                                self.cursorPositionChanged)

    def ignoreTextChanged(self, func):
        return self.ignoreEvent(func,
                                self.textEdit.textChanged,
                                self.textChanged)

    def initProperties(self):
        self.tokens = []
        self.formats = []
        self.mode = &#39;Level Mode&#39;  # LEVEL_MODE, EDITOR_MODE
        self.view = None  # PLAIN_TEXT_VIEW, SPACE_VIEW...
        self.filename = None

        self.editTokenDialog = EditTokenDialog(self)
        # self.dictionaryDialog = DictionaryEditorWidget(self)

    def initManagers(self):
        self.undoStk = QtWidgets.QUndoStack(self)
        self.actionManager = ActionManager(self)
        self.tokenManager = TokenManager(self)
        self.tokenList = Token(self)
        self.viewManager = ViewManager(self)
        self.formatManager = FormatManager(self)

    def initUI(self):
        self.actionManager.createActions()

        self.menuBar = MenuBar(self.actionManager, parent=self)
        self.setMenuBar(self.menuBar)

        # TODO group doesn&#39;t really work for mutually exclusive, has to be done manually
        # self.viewActionGroup =  QtWidgets.QActionGroup(self)
        # self.viewActionGroup.addAction(self.actionManager.spaceViewAction)
        # self.viewActionGroup.addAction(self.actionManager.tagViewAction)


        self.toolBar = ToolBar(self.actionManager, parent=self)
        self.addToolBar(self.toolBar)

        self.statusBar = StatusBar(parent=self)
        self.setStatusBar(self.statusBar)

        self.centralWidget = CentralWidget(self)
        self.setCentralWidget(self.centralWidget)

        self.highlighter = Highlighter(self.textEdit.document(), self)

        self.setStyleSheet(&#39;QMainWindow{background-color: white}&#39;)
        self.textEdit.setStyleSheet(
            &#39;border: none; margin: 10px&#39;)

        # default font and font size
        font = QtGui.QFont()
        font.setFamily(&#34;Microsoft Himalaya&#34;)
        font.setPointSize(14)
        self.textEdit.setFont(font)

        # font family
        self.toolBar.addSeparator()
        self.fontPicker = QtWidgets.QFontComboBox()
        self.toolBar.addWidget(self.fontPicker)
        self.fontPicker.setCurrentFont(self.textEdit.currentFont())

        # font size
        FONT_SIZES = [6, 8, 9, 10, 11, 12, 13, 14, 18, 24, 36, 48, 64, 72, 96, 144, 288]
        self.fontResizer = QtWidgets.QComboBox()
        self.toolBar.addWidget(self.fontResizer)
        self.fontResizer.addItems([str(s) for s in FONT_SIZES])
        self.fontResizer.setCurrentText(str(font.pointSize()))

        # update when font or size is changed
        self.fontPicker.currentFontChanged.connect(self.changeFont)
        self.fontResizer.currentIndexChanged.connect(self.changeFont)

    def changeFont(self):
        font = self.fontPicker.currentFont()
        font.setPointSize(int(self.fontResizer.currentText()))
        self.textEdit.setFont(font)

    def bindEvents(self):
        self.bindCursorPositionChanged()
        self.bindTextChanged()
        self.bindLevelButtons()

    def bindCursorPositionChanged(self):
        self.textEdit.cursorPositionChanged.connect(self.cursorPositionChanged)

    def bindTextChanged(self):
        self.textEdit.textChanged.connect(self.textChanged)

    def bindLevelButtons(self):
        self.levelTab.level1Button.clicked.connect(
            partial(self.importLevelList, level=1, levelNum=self.levelTab.level1Button))

        self.levelTab.level2Button.clicked.connect(
            partial(self.importLevelList, level=2, levelNum=self.levelTab.level2Button))

        self.levelTab.level3Button.clicked.connect(
            partial(self.importLevelList, level=3, levelNum=self.levelTab.level3Button))

    def closeEvent(self, *args, **kwargs):

        import pickle
        with self.bt.pickled_file.open(&#39;wb&#39;) as f:
            pickle.dump(self.bt.head, f, pickle.HIGHEST_PROTOCOL)

        super().closeEvent(*args, **kwargs)

    def toggleSpaceView(self):
        if self.viewManager.isPlainTextView():
            self.segment()
        
        self.viewManager.toggleSpaceView()
        self.refreshView()

    def toggleTagView(self):
        if self.viewManager.isPlainTextView():
            self.segment()
        self.viewManager.toggleTagView()
        self.refreshView()

    def segment(self, byBlock=False, breakLine=False):
        &#34;&#34;&#34;
        1. Gets the text in textedit, 2. segments it with pybo,
        3. assigns a lists of Token objects to self.tokens,
        4. displays text with refreshview().
        Segmentation by blocks avoids resegmenting the whole document at each change 
            :param self: Editor
            :param byBlock=False: 
            :param breakLine=False: 
        &#34;&#34;&#34;
        if byBlock:
            block = self.textEdit.textCursor().block()
            string = block.text()

            if breakLine:
                block = block.previous()
                string = block.text() + &#39;\n&#39;

            tokens = self.tokenManager.segment(string)
            startIndex, endIndex = self.tokenManager.findByBlockIndex(
                block.blockNumber())

            if startIndex is None:
                self.tokens.extend(tokens)

            else:
                self.tokens[startIndex: endIndex + 1] = tokens
        else:
            string = self.centralWidget.textEdit.toPlainText()
            self.tokens = self.tokenManager.segment(string)

        self.refreshView()

    def resegment(self):
        # FIXME is this really useful?
        string = &#39;&#39;.join([token.text for token in self.tokens])
        tokens = self.tokenManager.segment(string)
        self.tokens = tokens
        self.refreshView()

    @property
    def bt(self):
        return self.tokenManager.tokenizer.tok.trie

    # TextEdit #
    @property
    def textEdit(self):
        return self.centralWidget.textEdit

    @property
    def findWidget(self):
        return self.centralWidget.leftTabWidget.findTab

    @property
    def levelTab(self):
        return self.centralWidget.tabWidget.levelTab

    @property
    def editorTab(self):
        return self.centralWidget.tabWidget.editorTab

    def isLevelMode(self):
        return (self.centralWidget.tabWidget.currentIndex() == 0)

    def isEditorMode(self):
        return (self.centralWidget.tabWidget.currentIndex() == 1)

    # TextEdit Actions #
    def newFile(self):
        self.textEdit.newFile()

    def openFile(self):
        self.textEdit.openFile()
        self.segment()

    def saveFile(self):
        self.filename = self.textEdit.saveFile()

    def undo(self):
        # self.textEdit.undo()
        self.QUndoStack.undo()
        print(&#39;undo&#39;)

    def redo(self):
        # self.textEdit.redo()
        self.QUndoStack.redo()
        print(&#39;redo&#39;)

    # TextEdit Events #
    def cursorPositionChanged(self):
        cursor = self.textEdit.textCursor()
        position = cursor.position()

        if (self.viewManager.isTagView() and
                not self.editTokenDialog.isVisible()):
            token = self.tokenManager.find(position)[1]

            if token.pos == &#34;OOV&#34;:
                # TODO
                self.actionManager.dictionaryAction.trigger()
                self.dictionaryDialog.addWord(text=token.text)
            else:
                self.editTokenDialog.setMode(EditTokenDialog.MODE_UPDATE)
                self.editTokenDialog.setToken(token)
                self.editTokenDialog.show()

        self.showStatus(ln=cursor.blockNumber() + 1,
                        col=cursor.columnNumber() + 1)

    def textChanged(self):
        if self.viewManager.isPlainTextView():
            string = self.textEdit.toPlainText()

            if any([string.endswith(w) for w in self.SEGMENT_WORDS]):
                self.segment()
                # self.segment(byBlock=True)

            elif string.endswith(&#39;\n&#39;):
                self.segment()
                # TODO: block mode: bug - if we delete text and try to rewrite new
                # text it copies the already saved text.
                # self.segment(byBlock=True, breakLine=True)

            elif string == &#39;&#39;: 
                self.segment()

    # Import Level List#
    # TODO: set list names when starting the app
    def importLevelList(self, level, levelNum):
        filePath, _ = QtWidgets.QFileDialog.getOpenFileName(self, &#34;Select a level list&#34;, os.path.join(FILES_DIR, &#39;levels&#39;), filter=&#34;UTF-8 ཡིག་རྐྱང་། (*.txt)&#34;)
        splitFilePath = filePath.split(&#39;/&#39;)

        if &#39;&#39; in splitFilePath[:1]:
            return
        else:
            self.fileName = splitFilePath[len(splitFilePath) - 1]
            levelNum.setText(self.fileName)

        with open(filePath, encoding=&#39;utf-8&#39;) as f:
            words = [word[:-1] if word.endswith(&#39;་&#39;) else word
                     for word in [line.rstrip(&#39;\r\n&#39;)
                                  for line in f.readlines()]]

        with transaction.atomic():
            for word in words:
                token = Token.objects.get_or_create(
                    text=word, type=Token.TYPE_UPDATE)[0]
                token.level = level
                token.save()

        self.refreshView()

    def importRuleList(self, level):
        filePath, _ = QtWidgets.QFileDialog.getOpenFileName(self, &#34;Select a rule list&#34;, os.path.join(FILES_DIR, &#39;levels&#39;), filter=&#34;UTF-8 ཡིག་རྐྱང་། (*.txt)&#34;)

        with open(filePath, encoding=&#39;utf-8&#39;) as f:
            rules = [line.rstrip(&#39;\r\n&#39;) for line in f.readlines()]

        self.matcher.match(self.tokens, rules)

        self.refreshView()

    # Refresh #
    def refreshView(self):
        &#34;&#34;&#34;
        docstring here
            :param self: 
        &#34;&#34;&#34;
        # Adds token info from the db
        # - level
        # - sense
        self.tokenManager.applyDict()

        # 
        self.tokenManager.matchRules()

        # keep cursor
        textCursor = self.textEdit.textCursor()
        current = self.tokenManager.find(textCursor.position())

        if current is not None:
            currentToken = current[1]
            distance = textCursor.position() - currentToken.start

        text = self.tokenManager.getString()

        # # Sets text in textEdit before moving on to highlighting
        # self.textEdit.setPlainText(text)

        command = CommandEditText(self.textEdit, text, &#34;Edit text&#34;)
        self.undoStk.push(command)

        if current is not None:
            textCursor.setPosition(currentToken.start + distance)
        else:
            textCursor.setPosition(len(self.textEdit.toPlainText()))

        self.ignoreCursorPositionChanged(
            self.textEdit.setTextCursor)(textCursor)
        self.refreshCoverage()

        # print([t.text for t in self.tokens])
        self.statusBar.showMessage(
            &#39;  &#39; + &#39; &#39;.join([t.text for t in self.tokens[-19:]]))

    def statistics(self):

        # to do: bug fix -
        # if we press enter twice sentence count reinitializes
        # you need to press on enter for it to recognize that the text editor is empty
        # it considers བོད and བོད་ different - the difference is the tseg (not sure if that is a bug)
        # It always counts the first enter

        # Statistics - analyze the text in the text editor

        wordCount = 0  # number of words written
        sentenceCount = 0  # number of sentence written - each new line is considered one sentnece
        typeCount = 0  # number of words used
        max = 0  # maximum number of words in a sentence - longest sentence
        counts = dict()
        sentenceWordCount = []  # records the number of words in each sentence
        wordSentence = 0  # words in a sentence
        verbsPerSen = 0  # verbs in a sentence
        verbSentence = []  # records the number of verbs in each sentence

        # parse through the list and not count the newline
        # for now every newline is considered a completion of one sentence
        for token in self.tokens:

            if token.text == &#34;།&#34;:
                continue
            if token.text != &#34;\n&#34;:
                wordCount += 1
                wordSentence += 1
                if token.pos == &#34;VERB&#34;:
                    verbsPerSen += 1
                if token.text in counts:
                    continue
                else:
                    counts[token.text] = 1
                    typeCount += 1
            else:
                if wordCount == 0:
                    continue
                verbSentence.append(verbsPerSen)
                sentenceCount += 1
                sentenceWordCount.append(wordSentence)
                if max &lt; sentenceWordCount[sentenceCount - 1]:
                    max = sentenceWordCount[sentenceCount - 1]
                wordSentence = 0
                verbsPerSen = 0

        # print(&#34;maximum words in a sentence: &#34;, max)
        # print(&#34;word count: &#34;, wordCount)
        # print(&#34;type count: &#34;, typeCount)
        # print(&#34;sentence count: &#34;, sentenceCount)

        # frequency - the number of times a token is repeated
        frequency = Counter([
            (token.text, token.type, token.pos, token.text_unaffixed) for token in self.tokens])
        print(&#34;Frequency: &#34;, frequency)

        # Updating the Statistics
        self.levelTab.wordCountLabel.setText(str(wordCount))
        self.levelTab.typeCountLabel.setText(str(typeCount))
        self.levelTab.senCountLabel.setText(str(sentenceCount))
        self.levelTab.maxWordLabel.setText(str(max))

    def refreshCoverage(self):

        tokenNum = sum(1 for t in self.tokens if t.type == &#39;TEXT&#39;)
        print(&#39;tokenNum: &#39;, tokenNum)

        self.statistics()

        levelCounter = Counter([
            token.level for token in self.tokens if token.type == &#39;TEXT&#39;])


        def getLevelPercentage(key):
            if tokenNum == 0:
                return 0
            else:
                return levelCounter[key] / tokenNum * 100.0

        # updating the progress bar
        self.levelTab.tokenCoverageProgBar.setValue(100 - getLevelPercentage(None))
        self.levelTab.levelNoneProgBar.setValue(getLevelPercentage(None))
        self.levelTab.level1ProgBar.setValue(getLevelPercentage(1))
        self.levelTab.level2ProgBar.setValue(getLevelPercentage(2))
        self.levelTab.level3ProgBar.setValue(getLevelPercentage(3))

        posCounter = Counter([
            token.pos for token in self.tokens])

        posFreq = posCounter.most_common()
        print(posFreq)
        &#34;&#34;&#34;
        if len(posFreq) &gt;= 1:
            self.editorTab.firstFreqLabel.setText(posFreq[0][0])
            self.editorTab.firstFreqProgBar.setValue(
                posFreq[0][1] / tokenNum * 100.0)

        if len(posFreq) &gt;= 2:
            self.editorTab.secondFreqLabel.setText(posFreq[1][0])
            self.editorTab.secondFreqProgBar.setValue(
                posFreq[1][1] / tokenNum * 100.0)

        if len(posFreq) &gt;= 3:
            self.editorTab.thirdFreqLabel.setText(posFreq[2][0])
            self.editorTab.thirdFreqProgBar.setValue(
                posFreq[2][1] / tokenNum * 100.0)
        &#34;&#34;&#34;

    def getHighlightedLevels(self):
        result = []
        if self.levelTab.levelNoneCheckbox.isChecked():
            result.append(None)
        if self.levelTab.level1Checkbox.isChecked():
            result.append(1)
        if self.levelTab.level2Checkbox.isChecked():
            result.append(2)
        if self.levelTab.level3Checkbox.isChecked():
            result.append(3)
        return result

    def getHighlightedPoses(self):
        result = []
        if self.editorTab.firstFreqCheckbox.isChecked():
            result.append(self.editorTab.firstFreqLabel.text())
        if self.editorTab.secondFreqCheckbox.isChecked():
            result.append(self.editorTab.secondFreqLabel.text())
        if self.editorTab.thirdFreqCheckbox.isChecked():
            result.append(self.editorTab.thirdFreqLabel.text())
        return result

    def getPosRank(self, pos):
        if self.editorTab.firstFreqLabel.text() == pos:
            return 1
        elif self.editorTab.secondFreqLabel.text() == pos:
            return 2
        elif self.editorTab.thirdFreqLabel.text() == pos:
            return 3
        else:
            return None

    def showStatus(self, ln=None, col=None):
        self.statusBar.modeLabel.setText(self.mode)
        self.statusBar.viewLabel.setText(self.viewManager.getStatusDisplay())

        if ln and col:
            self.statusBar.lineLabel.setText(
                &#39;Ln {}, Col {}&#39;.format(ln, col))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Dakje.Editor.BASE_DIR"><code class="name">var <span class="ident">BASE_DIR</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="Dakje.Editor.SEGMENT_WORDS"><code class="name">var <span class="ident">SEGMENT_WORDS</span></code></dt>
<dd>
<section class="desc"><p>Built-in mutable sequence.</p>
<p>If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="Dakje.Editor.bt"><code class="name">var <span class="ident">bt</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bt(self):
    return self.tokenManager.tokenizer.tok.trie</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.editorTab"><code class="name">var <span class="ident">editorTab</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def editorTab(self):
    return self.centralWidget.tabWidget.editorTab</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.findWidget"><code class="name">var <span class="ident">findWidget</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def findWidget(self):
    return self.centralWidget.leftTabWidget.findTab</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.levelTab"><code class="name">var <span class="ident">levelTab</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def levelTab(self):
    return self.centralWidget.tabWidget.levelTab</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.textEdit"><code class="name">var <span class="ident">textEdit</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def textEdit(self):
    return self.centralWidget.textEdit</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Dakje.Editor.bindCursorPositionChanged"><code class="name flex">
<span>def <span class="ident">bindCursorPositionChanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bindCursorPositionChanged(self):
    self.textEdit.cursorPositionChanged.connect(self.cursorPositionChanged)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.bindEvents"><code class="name flex">
<span>def <span class="ident">bindEvents</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bindEvents(self):
    self.bindCursorPositionChanged()
    self.bindTextChanged()
    self.bindLevelButtons()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.bindLevelButtons"><code class="name flex">
<span>def <span class="ident">bindLevelButtons</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bindLevelButtons(self):
    self.levelTab.level1Button.clicked.connect(
        partial(self.importLevelList, level=1, levelNum=self.levelTab.level1Button))

    self.levelTab.level2Button.clicked.connect(
        partial(self.importLevelList, level=2, levelNum=self.levelTab.level2Button))

    self.levelTab.level3Button.clicked.connect(
        partial(self.importLevelList, level=3, levelNum=self.levelTab.level3Button))</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.bindTextChanged"><code class="name flex">
<span>def <span class="ident">bindTextChanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bindTextChanged(self):
    self.textEdit.textChanged.connect(self.textChanged)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.changeFont"><code class="name flex">
<span>def <span class="ident">changeFont</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeFont(self):
    font = self.fontPicker.currentFont()
    font.setPointSize(int(self.fontResizer.currentText()))
    self.textEdit.setFont(font)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.closeEvent"><code class="name flex">
<span>def <span class="ident">closeEvent</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>closeEvent(self, QCloseEvent)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeEvent(self, *args, **kwargs):

    import pickle
    with self.bt.pickled_file.open(&#39;wb&#39;) as f:
        pickle.dump(self.bt.head, f, pickle.HIGHEST_PROTOCOL)

    super().closeEvent(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.cursorPositionChanged"><code class="name flex">
<span>def <span class="ident">cursorPositionChanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cursorPositionChanged(self):
    cursor = self.textEdit.textCursor()
    position = cursor.position()

    if (self.viewManager.isTagView() and
            not self.editTokenDialog.isVisible()):
        token = self.tokenManager.find(position)[1]

        if token.pos == &#34;OOV&#34;:
            # TODO
            self.actionManager.dictionaryAction.trigger()
            self.dictionaryDialog.addWord(text=token.text)
        else:
            self.editTokenDialog.setMode(EditTokenDialog.MODE_UPDATE)
            self.editTokenDialog.setToken(token)
            self.editTokenDialog.show()

    self.showStatus(ln=cursor.blockNumber() + 1,
                    col=cursor.columnNumber() + 1)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.getHighlightedLevels"><code class="name flex">
<span>def <span class="ident">getHighlightedLevels</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHighlightedLevels(self):
    result = []
    if self.levelTab.levelNoneCheckbox.isChecked():
        result.append(None)
    if self.levelTab.level1Checkbox.isChecked():
        result.append(1)
    if self.levelTab.level2Checkbox.isChecked():
        result.append(2)
    if self.levelTab.level3Checkbox.isChecked():
        result.append(3)
    return result</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.getHighlightedPoses"><code class="name flex">
<span>def <span class="ident">getHighlightedPoses</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHighlightedPoses(self):
    result = []
    if self.editorTab.firstFreqCheckbox.isChecked():
        result.append(self.editorTab.firstFreqLabel.text())
    if self.editorTab.secondFreqCheckbox.isChecked():
        result.append(self.editorTab.secondFreqLabel.text())
    if self.editorTab.thirdFreqCheckbox.isChecked():
        result.append(self.editorTab.thirdFreqLabel.text())
    return result</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.getPosRank"><code class="name flex">
<span>def <span class="ident">getPosRank</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPosRank(self, pos):
    if self.editorTab.firstFreqLabel.text() == pos:
        return 1
    elif self.editorTab.secondFreqLabel.text() == pos:
        return 2
    elif self.editorTab.thirdFreqLabel.text() == pos:
        return 3
    else:
        return None</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.ignoreCursorPositionChanged"><code class="name flex">
<span>def <span class="ident">ignoreCursorPositionChanged</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ignoreCursorPositionChanged(self, func):
    return self.ignoreEvent(func,
                            self.textEdit.cursorPositionChanged,
                            self.cursorPositionChanged)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.ignoreEvent"><code class="name flex">
<span>def <span class="ident">ignoreEvent</span></span>(<span>self, func, signal, event)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ignoreEvent(self, func, signal, event):
    def _func(*arg, **kwargs):
        signal.disconnect()
        func(*arg, **kwargs)
        signal.connect(event)
    return _func</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.ignoreTextChanged"><code class="name flex">
<span>def <span class="ident">ignoreTextChanged</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ignoreTextChanged(self, func):
    return self.ignoreEvent(func,
                            self.textEdit.textChanged,
                            self.textChanged)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.importLevelList"><code class="name flex">
<span>def <span class="ident">importLevelList</span></span>(<span>self, level, levelNum)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importLevelList(self, level, levelNum):
    filePath, _ = QtWidgets.QFileDialog.getOpenFileName(self, &#34;Select a level list&#34;, os.path.join(FILES_DIR, &#39;levels&#39;), filter=&#34;UTF-8 ཡིག་རྐྱང་། (*.txt)&#34;)
    splitFilePath = filePath.split(&#39;/&#39;)

    if &#39;&#39; in splitFilePath[:1]:
        return
    else:
        self.fileName = splitFilePath[len(splitFilePath) - 1]
        levelNum.setText(self.fileName)

    with open(filePath, encoding=&#39;utf-8&#39;) as f:
        words = [word[:-1] if word.endswith(&#39;་&#39;) else word
                 for word in [line.rstrip(&#39;\r\n&#39;)
                              for line in f.readlines()]]

    with transaction.atomic():
        for word in words:
            token = Token.objects.get_or_create(
                text=word, type=Token.TYPE_UPDATE)[0]
            token.level = level
            token.save()

    self.refreshView()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.importRuleList"><code class="name flex">
<span>def <span class="ident">importRuleList</span></span>(<span>self, level)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importRuleList(self, level):
    filePath, _ = QtWidgets.QFileDialog.getOpenFileName(self, &#34;Select a rule list&#34;, os.path.join(FILES_DIR, &#39;levels&#39;), filter=&#34;UTF-8 ཡིག་རྐྱང་། (*.txt)&#34;)

    with open(filePath, encoding=&#39;utf-8&#39;) as f:
        rules = [line.rstrip(&#39;\r\n&#39;) for line in f.readlines()]

    self.matcher.match(self.tokens, rules)

    self.refreshView()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.initManagers"><code class="name flex">
<span>def <span class="ident">initManagers</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initManagers(self):
    self.undoStk = QtWidgets.QUndoStack(self)
    self.actionManager = ActionManager(self)
    self.tokenManager = TokenManager(self)
    self.tokenList = Token(self)
    self.viewManager = ViewManager(self)
    self.formatManager = FormatManager(self)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.initProperties"><code class="name flex">
<span>def <span class="ident">initProperties</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initProperties(self):
    self.tokens = []
    self.formats = []
    self.mode = &#39;Level Mode&#39;  # LEVEL_MODE, EDITOR_MODE
    self.view = None  # PLAIN_TEXT_VIEW, SPACE_VIEW...
    self.filename = None

    self.editTokenDialog = EditTokenDialog(self)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.initUI"><code class="name flex">
<span>def <span class="ident">initUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initUI(self):
    self.actionManager.createActions()

    self.menuBar = MenuBar(self.actionManager, parent=self)
    self.setMenuBar(self.menuBar)

    # TODO group doesn&#39;t really work for mutually exclusive, has to be done manually
    # self.viewActionGroup =  QtWidgets.QActionGroup(self)
    # self.viewActionGroup.addAction(self.actionManager.spaceViewAction)
    # self.viewActionGroup.addAction(self.actionManager.tagViewAction)


    self.toolBar = ToolBar(self.actionManager, parent=self)
    self.addToolBar(self.toolBar)

    self.statusBar = StatusBar(parent=self)
    self.setStatusBar(self.statusBar)

    self.centralWidget = CentralWidget(self)
    self.setCentralWidget(self.centralWidget)

    self.highlighter = Highlighter(self.textEdit.document(), self)

    self.setStyleSheet(&#39;QMainWindow{background-color: white}&#39;)
    self.textEdit.setStyleSheet(
        &#39;border: none; margin: 10px&#39;)

    # default font and font size
    font = QtGui.QFont()
    font.setFamily(&#34;Microsoft Himalaya&#34;)
    font.setPointSize(14)
    self.textEdit.setFont(font)

    # font family
    self.toolBar.addSeparator()
    self.fontPicker = QtWidgets.QFontComboBox()
    self.toolBar.addWidget(self.fontPicker)
    self.fontPicker.setCurrentFont(self.textEdit.currentFont())

    # font size
    FONT_SIZES = [6, 8, 9, 10, 11, 12, 13, 14, 18, 24, 36, 48, 64, 72, 96, 144, 288]
    self.fontResizer = QtWidgets.QComboBox()
    self.toolBar.addWidget(self.fontResizer)
    self.fontResizer.addItems([str(s) for s in FONT_SIZES])
    self.fontResizer.setCurrentText(str(font.pointSize()))

    # update when font or size is changed
    self.fontPicker.currentFontChanged.connect(self.changeFont)
    self.fontResizer.currentIndexChanged.connect(self.changeFont)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.isEditorMode"><code class="name flex">
<span>def <span class="ident">isEditorMode</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isEditorMode(self):
    return (self.centralWidget.tabWidget.currentIndex() == 1)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.isLevelMode"><code class="name flex">
<span>def <span class="ident">isLevelMode</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isLevelMode(self):
    return (self.centralWidget.tabWidget.currentIndex() == 0)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.newFile"><code class="name flex">
<span>def <span class="ident">newFile</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newFile(self):
    self.textEdit.newFile()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.openFile"><code class="name flex">
<span>def <span class="ident">openFile</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openFile(self):
    self.textEdit.openFile()
    self.segment()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.redo"><code class="name flex">
<span>def <span class="ident">redo</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redo(self):
    # self.textEdit.redo()
    self.QUndoStack.redo()
    print(&#39;redo&#39;)</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.refreshCoverage"><code class="name flex">
<span>def <span class="ident">refreshCoverage</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refreshCoverage(self):

    tokenNum = sum(1 for t in self.tokens if t.type == &#39;TEXT&#39;)
    print(&#39;tokenNum: &#39;, tokenNum)

    self.statistics()

    levelCounter = Counter([
        token.level for token in self.tokens if token.type == &#39;TEXT&#39;])


    def getLevelPercentage(key):
        if tokenNum == 0:
            return 0
        else:
            return levelCounter[key] / tokenNum * 100.0

    # updating the progress bar
    self.levelTab.tokenCoverageProgBar.setValue(100 - getLevelPercentage(None))
    self.levelTab.levelNoneProgBar.setValue(getLevelPercentage(None))
    self.levelTab.level1ProgBar.setValue(getLevelPercentage(1))
    self.levelTab.level2ProgBar.setValue(getLevelPercentage(2))
    self.levelTab.level3ProgBar.setValue(getLevelPercentage(3))

    posCounter = Counter([
        token.pos for token in self.tokens])

    posFreq = posCounter.most_common()
    print(posFreq)
    &#34;&#34;&#34;
    if len(posFreq) &gt;= 1:
        self.editorTab.firstFreqLabel.setText(posFreq[0][0])
        self.editorTab.firstFreqProgBar.setValue(
            posFreq[0][1] / tokenNum * 100.0)

    if len(posFreq) &gt;= 2:
        self.editorTab.secondFreqLabel.setText(posFreq[1][0])
        self.editorTab.secondFreqProgBar.setValue(
            posFreq[1][1] / tokenNum * 100.0)

    if len(posFreq) &gt;= 3:
        self.editorTab.thirdFreqLabel.setText(posFreq[2][0])
        self.editorTab.thirdFreqProgBar.setValue(
            posFreq[2][1] / tokenNum * 100.0)
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.refreshView"><code class="name flex">
<span>def <span class="ident">refreshView</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>docstring here
:param self:</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refreshView(self):
    &#34;&#34;&#34;
    docstring here
        :param self: 
    &#34;&#34;&#34;
    # Adds token info from the db
    # - level
    # - sense
    self.tokenManager.applyDict()

    # 
    self.tokenManager.matchRules()

    # keep cursor
    textCursor = self.textEdit.textCursor()
    current = self.tokenManager.find(textCursor.position())

    if current is not None:
        currentToken = current[1]
        distance = textCursor.position() - currentToken.start

    text = self.tokenManager.getString()

    # # Sets text in textEdit before moving on to highlighting
    # self.textEdit.setPlainText(text)

    command = CommandEditText(self.textEdit, text, &#34;Edit text&#34;)
    self.undoStk.push(command)

    if current is not None:
        textCursor.setPosition(currentToken.start + distance)
    else:
        textCursor.setPosition(len(self.textEdit.toPlainText()))

    self.ignoreCursorPositionChanged(
        self.textEdit.setTextCursor)(textCursor)
    self.refreshCoverage()

    # print([t.text for t in self.tokens])
    self.statusBar.showMessage(
        &#39;  &#39; + &#39; &#39;.join([t.text for t in self.tokens[-19:]]))</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.resegment"><code class="name flex">
<span>def <span class="ident">resegment</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resegment(self):
    # FIXME is this really useful?
    string = &#39;&#39;.join([token.text for token in self.tokens])
    tokens = self.tokenManager.segment(string)
    self.tokens = tokens
    self.refreshView()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.saveFile"><code class="name flex">
<span>def <span class="ident">saveFile</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveFile(self):
    self.filename = self.textEdit.saveFile()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.segment"><code class="name flex">
<span>def <span class="ident">segment</span></span>(<span>self, byBlock=False, breakLine=False)</span>
</code></dt>
<dd>
<section class="desc"><ol>
<li>Gets the text in textedit, 2. segments it with pybo,</li>
<li>assigns a lists of Token objects to self.tokens,</li>
<li>displays text with refreshview().
Segmentation by blocks avoids resegmenting the whole document at each change
:param self: Editor
:param byBlock=False:
:param breakLine=False:</li>
</ol></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment(self, byBlock=False, breakLine=False):
    &#34;&#34;&#34;
    1. Gets the text in textedit, 2. segments it with pybo,
    3. assigns a lists of Token objects to self.tokens,
    4. displays text with refreshview().
    Segmentation by blocks avoids resegmenting the whole document at each change 
        :param self: Editor
        :param byBlock=False: 
        :param breakLine=False: 
    &#34;&#34;&#34;
    if byBlock:
        block = self.textEdit.textCursor().block()
        string = block.text()

        if breakLine:
            block = block.previous()
            string = block.text() + &#39;\n&#39;

        tokens = self.tokenManager.segment(string)
        startIndex, endIndex = self.tokenManager.findByBlockIndex(
            block.blockNumber())

        if startIndex is None:
            self.tokens.extend(tokens)

        else:
            self.tokens[startIndex: endIndex + 1] = tokens
    else:
        string = self.centralWidget.textEdit.toPlainText()
        self.tokens = self.tokenManager.segment(string)

    self.refreshView()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.showStatus"><code class="name flex">
<span>def <span class="ident">showStatus</span></span>(<span>self, ln=None, col=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showStatus(self, ln=None, col=None):
    self.statusBar.modeLabel.setText(self.mode)
    self.statusBar.viewLabel.setText(self.viewManager.getStatusDisplay())

    if ln and col:
        self.statusBar.lineLabel.setText(
            &#39;Ln {}, Col {}&#39;.format(ln, col))</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.statistics"><code class="name flex">
<span>def <span class="ident">statistics</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def statistics(self):

    # to do: bug fix -
    # if we press enter twice sentence count reinitializes
    # you need to press on enter for it to recognize that the text editor is empty
    # it considers བོད and བོད་ different - the difference is the tseg (not sure if that is a bug)
    # It always counts the first enter

    # Statistics - analyze the text in the text editor

    wordCount = 0  # number of words written
    sentenceCount = 0  # number of sentence written - each new line is considered one sentnece
    typeCount = 0  # number of words used
    max = 0  # maximum number of words in a sentence - longest sentence
    counts = dict()
    sentenceWordCount = []  # records the number of words in each sentence
    wordSentence = 0  # words in a sentence
    verbsPerSen = 0  # verbs in a sentence
    verbSentence = []  # records the number of verbs in each sentence

    # parse through the list and not count the newline
    # for now every newline is considered a completion of one sentence
    for token in self.tokens:

        if token.text == &#34;།&#34;:
            continue
        if token.text != &#34;\n&#34;:
            wordCount += 1
            wordSentence += 1
            if token.pos == &#34;VERB&#34;:
                verbsPerSen += 1
            if token.text in counts:
                continue
            else:
                counts[token.text] = 1
                typeCount += 1
        else:
            if wordCount == 0:
                continue
            verbSentence.append(verbsPerSen)
            sentenceCount += 1
            sentenceWordCount.append(wordSentence)
            if max &lt; sentenceWordCount[sentenceCount - 1]:
                max = sentenceWordCount[sentenceCount - 1]
            wordSentence = 0
            verbsPerSen = 0

    # print(&#34;maximum words in a sentence: &#34;, max)
    # print(&#34;word count: &#34;, wordCount)
    # print(&#34;type count: &#34;, typeCount)
    # print(&#34;sentence count: &#34;, sentenceCount)

    # frequency - the number of times a token is repeated
    frequency = Counter([
        (token.text, token.type, token.pos, token.text_unaffixed) for token in self.tokens])
    print(&#34;Frequency: &#34;, frequency)

    # Updating the Statistics
    self.levelTab.wordCountLabel.setText(str(wordCount))
    self.levelTab.typeCountLabel.setText(str(typeCount))
    self.levelTab.senCountLabel.setText(str(sentenceCount))
    self.levelTab.maxWordLabel.setText(str(max))</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.textChanged"><code class="name flex">
<span>def <span class="ident">textChanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def textChanged(self):
    if self.viewManager.isPlainTextView():
        string = self.textEdit.toPlainText()

        if any([string.endswith(w) for w in self.SEGMENT_WORDS]):
            self.segment()
            # self.segment(byBlock=True)

        elif string.endswith(&#39;\n&#39;):
            self.segment()
            # TODO: block mode: bug - if we delete text and try to rewrite new
            # text it copies the already saved text.
            # self.segment(byBlock=True, breakLine=True)

        elif string == &#39;&#39;: 
            self.segment()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.toggleSpaceView"><code class="name flex">
<span>def <span class="ident">toggleSpaceView</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggleSpaceView(self):
    if self.viewManager.isPlainTextView():
        self.segment()
    
    self.viewManager.toggleSpaceView()
    self.refreshView()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.toggleTagView"><code class="name flex">
<span>def <span class="ident">toggleTagView</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggleTagView(self):
    if self.viewManager.isPlainTextView():
        self.segment()
    self.viewManager.toggleTagView()
    self.refreshView()</code></pre>
</details>
</dd>
<dt id="Dakje.Editor.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undo(self):
    # self.textEdit.undo()
    self.QUndoStack.undo()
    print(&#39;undo&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Dakje.ExceptionHandler"><code class="flex name class">
<span>class <span class="ident">ExceptionHandler</span></span>
</code></dt>
<dd>
<section class="desc"><p>QObject(parent: QObject = None)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExceptionHandler(QtCore.QObject):

    errorSignal = QtCore.pyqtSignal()

    def __init__(self):
        super(ExceptionHandler, self).__init__()

    def handler(self, exctype, value, traceback):
        self.errorSignal.emit()
        sys._excepthook(exctype, value, traceback)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Dakje.ExceptionHandler.errorSignal"><code class="name flex">
<span>def <span class="ident">errorSignal</span></span>(<span>...)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="Dakje.ExceptionHandler.handler"><code class="name flex">
<span>def <span class="ident">handler</span></span>(<span>self, exctype, value, traceback)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handler(self, exctype, value, traceback):
    self.errorSignal.emit()
    sys._excepthook(exctype, value, traceback)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Dakje.main" href="#Dakje.main">main</a></code></li>
<li><code><a title="Dakje.runserver" href="#Dakje.runserver">runserver</a></code></li>
<li><code><a title="Dakje.timed" href="#Dakje.timed">timed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Dakje.CommandEditText" href="#Dakje.CommandEditText">CommandEditText</a></code></h4>
<ul class="">
<li><code><a title="Dakje.CommandEditText.redo" href="#Dakje.CommandEditText.redo">redo</a></code></li>
<li><code><a title="Dakje.CommandEditText.undo" href="#Dakje.CommandEditText.undo">undo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Dakje.Editor" href="#Dakje.Editor">Editor</a></code></h4>
<ul class="">
<li><code><a title="Dakje.Editor.BASE_DIR" href="#Dakje.Editor.BASE_DIR">BASE_DIR</a></code></li>
<li><code><a title="Dakje.Editor.SEGMENT_WORDS" href="#Dakje.Editor.SEGMENT_WORDS">SEGMENT_WORDS</a></code></li>
<li><code><a title="Dakje.Editor.bindCursorPositionChanged" href="#Dakje.Editor.bindCursorPositionChanged">bindCursorPositionChanged</a></code></li>
<li><code><a title="Dakje.Editor.bindEvents" href="#Dakje.Editor.bindEvents">bindEvents</a></code></li>
<li><code><a title="Dakje.Editor.bindLevelButtons" href="#Dakje.Editor.bindLevelButtons">bindLevelButtons</a></code></li>
<li><code><a title="Dakje.Editor.bindTextChanged" href="#Dakje.Editor.bindTextChanged">bindTextChanged</a></code></li>
<li><code><a title="Dakje.Editor.bt" href="#Dakje.Editor.bt">bt</a></code></li>
<li><code><a title="Dakje.Editor.changeFont" href="#Dakje.Editor.changeFont">changeFont</a></code></li>
<li><code><a title="Dakje.Editor.closeEvent" href="#Dakje.Editor.closeEvent">closeEvent</a></code></li>
<li><code><a title="Dakje.Editor.cursorPositionChanged" href="#Dakje.Editor.cursorPositionChanged">cursorPositionChanged</a></code></li>
<li><code><a title="Dakje.Editor.editorTab" href="#Dakje.Editor.editorTab">editorTab</a></code></li>
<li><code><a title="Dakje.Editor.findWidget" href="#Dakje.Editor.findWidget">findWidget</a></code></li>
<li><code><a title="Dakje.Editor.getHighlightedLevels" href="#Dakje.Editor.getHighlightedLevels">getHighlightedLevels</a></code></li>
<li><code><a title="Dakje.Editor.getHighlightedPoses" href="#Dakje.Editor.getHighlightedPoses">getHighlightedPoses</a></code></li>
<li><code><a title="Dakje.Editor.getPosRank" href="#Dakje.Editor.getPosRank">getPosRank</a></code></li>
<li><code><a title="Dakje.Editor.ignoreCursorPositionChanged" href="#Dakje.Editor.ignoreCursorPositionChanged">ignoreCursorPositionChanged</a></code></li>
<li><code><a title="Dakje.Editor.ignoreEvent" href="#Dakje.Editor.ignoreEvent">ignoreEvent</a></code></li>
<li><code><a title="Dakje.Editor.ignoreTextChanged" href="#Dakje.Editor.ignoreTextChanged">ignoreTextChanged</a></code></li>
<li><code><a title="Dakje.Editor.importLevelList" href="#Dakje.Editor.importLevelList">importLevelList</a></code></li>
<li><code><a title="Dakje.Editor.importRuleList" href="#Dakje.Editor.importRuleList">importRuleList</a></code></li>
<li><code><a title="Dakje.Editor.initManagers" href="#Dakje.Editor.initManagers">initManagers</a></code></li>
<li><code><a title="Dakje.Editor.initProperties" href="#Dakje.Editor.initProperties">initProperties</a></code></li>
<li><code><a title="Dakje.Editor.initUI" href="#Dakje.Editor.initUI">initUI</a></code></li>
<li><code><a title="Dakje.Editor.isEditorMode" href="#Dakje.Editor.isEditorMode">isEditorMode</a></code></li>
<li><code><a title="Dakje.Editor.isLevelMode" href="#Dakje.Editor.isLevelMode">isLevelMode</a></code></li>
<li><code><a title="Dakje.Editor.levelTab" href="#Dakje.Editor.levelTab">levelTab</a></code></li>
<li><code><a title="Dakje.Editor.newFile" href="#Dakje.Editor.newFile">newFile</a></code></li>
<li><code><a title="Dakje.Editor.openFile" href="#Dakje.Editor.openFile">openFile</a></code></li>
<li><code><a title="Dakje.Editor.redo" href="#Dakje.Editor.redo">redo</a></code></li>
<li><code><a title="Dakje.Editor.refreshCoverage" href="#Dakje.Editor.refreshCoverage">refreshCoverage</a></code></li>
<li><code><a title="Dakje.Editor.refreshView" href="#Dakje.Editor.refreshView">refreshView</a></code></li>
<li><code><a title="Dakje.Editor.resegment" href="#Dakje.Editor.resegment">resegment</a></code></li>
<li><code><a title="Dakje.Editor.saveFile" href="#Dakje.Editor.saveFile">saveFile</a></code></li>
<li><code><a title="Dakje.Editor.segment" href="#Dakje.Editor.segment">segment</a></code></li>
<li><code><a title="Dakje.Editor.showStatus" href="#Dakje.Editor.showStatus">showStatus</a></code></li>
<li><code><a title="Dakje.Editor.statistics" href="#Dakje.Editor.statistics">statistics</a></code></li>
<li><code><a title="Dakje.Editor.textChanged" href="#Dakje.Editor.textChanged">textChanged</a></code></li>
<li><code><a title="Dakje.Editor.textEdit" href="#Dakje.Editor.textEdit">textEdit</a></code></li>
<li><code><a title="Dakje.Editor.toggleSpaceView" href="#Dakje.Editor.toggleSpaceView">toggleSpaceView</a></code></li>
<li><code><a title="Dakje.Editor.toggleTagView" href="#Dakje.Editor.toggleTagView">toggleTagView</a></code></li>
<li><code><a title="Dakje.Editor.undo" href="#Dakje.Editor.undo">undo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Dakje.ExceptionHandler" href="#Dakje.ExceptionHandler">ExceptionHandler</a></code></h4>
<ul class="">
<li><code><a title="Dakje.ExceptionHandler.errorSignal" href="#Dakje.ExceptionHandler.errorSignal">errorSignal</a></code></li>
<li><code><a title="Dakje.ExceptionHandler.handler" href="#Dakje.ExceptionHandler.handler">handler</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>